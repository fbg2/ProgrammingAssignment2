################################################################################
##
## function: makeCacheMatrix
## Inputs: x -- assumed to be a square matirx
## Output: a list as descrbied below
##
##   ---------------
##
##  creates a special "matrix", which is really a list containing a function to:
## 
## set the value of the matrix
## get the value of the matrix
## set the value of the inverse of the matrix
## get the value of the inverse of the matrix
##
################################################################################
makeCacheMatrix <- function(x = matrix()) {
  theInverse <- NULL
  set <- function(y) {
    x <<- y
    theInverse <<- NULL
  }
  get <- function() x
  setinverse <- function(inv) theInverse <<- inv
  getinverse <- function() theInverse
  list(set = set, get = get,
       setinverse = setinverse,
       getinverse = getinverse)
}


################################################################################
##
## function: cacheSolve
## Inputs: x -- assumed to be a list "object" generated by makeCacheMatrix()
## Output: the inverse of the matrix stored in x
##
##   ---------------
## calculates the inverse  of the special "matrix" created with the above
## function. However, it first checks to see if the inverse has already been
## calculated. If so, it gets the inverse from the cache and skips the
## computation. Otherwise, it calculates the inverse of the matrix and sets the
## value of the inverse in the cache via the setinverse function.
## 
################################################################################
cacheSolve <- function(x, ...) {
  ## Return a matrix that is the inverse of 'x'
  
  # first, grab the cached inverse
  m <- x$getinverse()
  # check to see if the cached inverse was actually there... (ie. not NULL)
  # ... if so, return the cached value and message the user
  if(!is.null(m)) {
    message("getting cached data")
    return(m)
  }
  
  #.... otherwise
  # get the cached matrix stored in x
  data <- x$get()
  # use R's "solve" function to invert the matrix
  # skip error checking for a square matirx per the instructions
  # on this problem set
  m <- solve(data, ...)
  # cache the inverse for next time
  x$setinverse(m)
  # return the result
  m
}

